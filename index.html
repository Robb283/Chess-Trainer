<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scacchi vs AI</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chessboardjs@1.0.0/www/css/chessboard.css" />
  <style>
    :root { --gap: 14px; --radius: 16px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; background: #0f172a; color: #e2e8f0; }
    header { padding: 18px 20px; background: #0b1222; border-bottom: 1px solid #1f2a44; position: sticky; top: 0; z-index: 2; }
    header h1 { margin: 0; font-size: 20px; letter-spacing: .3px; }
    main { display: grid; grid-template-columns: 1fr; gap: var(--gap); padding: 18px; max-width: 1100px; margin: 0 auto; }
    .layout { display: grid; grid-template-columns: 1fr; gap: var(--gap); }
    @media (min-width: 980px) { .layout { grid-template-columns: 520px 1fr; align-items: start; } }
    .card { background: #0b1222; border: 1px solid #1f2a44; border-radius: var(--radius); padding: 14px; }
    .toolbar { display: grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 8px; margin-top: 12px; }
    button, select, input[type="number"] { background: #0e1730; color: #e2e8f0; border: 1px solid #1f2a44; border-radius: 12px; padding: 10px 12px; font-size: 14px; }
    button { cursor: pointer; }
    button:hover { background: #101d3d; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .row3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .label { font-size: 12px; color: #94a3b8; margin-bottom: 6px; }
    .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 14px; background: #0b1222; border: 1px dashed #28365c; border-radius: 12px; padding: 10px; min-height: 44px; }
    .moves { height: 340px; overflow: auto; background: #0e1730; border: 1px solid #1f2a44; border-radius: 12px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; line-height: 1.6; font-size: 14px; }
    .pill { display: inline-block; padding: 6px 10px; border-radius: 999px; background: #16244c; border: 1px solid #2a3d72; font-size: 12px; }
    .section-title { margin: 10px 0 4px; font-size: 13px; color: #93c5fd; text-transform: uppercase; letter-spacing: .06em; }
    footer { text-align: center; color: #94a3b8; font-size: 12px; padding: 16px; }
    .hint { font-size: 12px; color: #94a3b8; }
    .divider { height: 1px; background: #1f2a44; margin: 10px 0; border-radius: 1px; }
  </style>
</head>
<body>
  <header>
    <h1>♟️ Scacchi vs AI — livelli di difficoltà</h1>
  </header>
  <main>
    <div class="layout">
      <section class="card">
        <div id="board" style="width: 100%; max-width: 520px; margin: 0 auto;"></div>
        <div class="toolbar">
          <button id="newGameBtn">Nuova partita</button>
          <button id="undoBtn">Annulla ultima mossa</button>
          <button id="flipBtn">Gira scacchiera</button>
        </div>
        <div style="margin-top:12px; display:grid; gap:10px;">
          <div>
            <div class="label">Gioca con:</div>
            <div class="row3">
              <button data-side="white">⚪ Bianco</button>
              <button data-side="black">⚫ Nero</button>
              <span class="pill" id="sideNow">Lato: Bianco</span>
            </div>
          </div>
          <div class="divider"></div>
          <div class="row">
            <div>
              <div class="label">Difficoltà (0–20)</div>
              <input id="skill" type="number" min="0" max="20" value="8" />
            </div>
            <div>
              <div class="label">Tempo di calcolo AI (ms)</div>
              <input id="movetime" type="number" min="50" step="50" value="500" />
            </div>
          </div>
          <div class="row3">
            <button class="preset" data-skill="1" data-mt="250">Facile</button>
            <button class="preset" data-skill="8" data-mt="500">Medio</button>
            <button class="preset" data-skill="15" data-mt="1200">Difficile</button>
          </div>
          <div class="hint">Suggerimento: aumenta <strong>Difficoltà</strong> per mosse più forti; aumenta <strong>Tempo di calcolo</strong> per una profondità maggiore.</div>
        </div>
      </section>

      <section class="card">
        <div class="section-title">Stato</div>
        <div id="status" class="status">Pronto. Tocca a te giocare con il Bianco.</div>
        <div class="section-title">Mossette</div>
        <div id="moves" class="moves"></div>
      </section>
    </div>
    <footer>Open‑source: usa pure questo file come <em>index.html</em> su GitHub Pages.</footer>
  </main>

  <!-- Dipendenze -->
  <script src="https://cdn.jsdelivr.net/npm/chess.js@1.0.0/dist/chess.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chessboardjs@1.0.0/www/js/chessboard.js"></script>

  <script>
    // --- Stockfish come Web Worker tramite Blob che importa dallo CDN (CORS-safe) ---
    function createStockfish() {
      const blob = new Blob([
        `importScripts('https://cdn.jsdelivr.net/npm/stockfish@16/stockfish.js');` // usa WASM/JS auto
      ], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    }

    const game = new Chess();
    let board = null;
    let playerSide = 'white';
    let engine = createStockfish();
    let engineReady = false;
    let engineBusy = false;
    let flipped = false;

    const statusEl = document.getElementById('status');
    const movesEl  = document.getElementById('moves');
    const sideNowEl = document.getElementById('sideNow');
    const skillEl = document.getElementById('skill');
    const movetimeEl = document.getElementById('movetime');

    function uci(cmd) { engine.postMessage(cmd); }

    function initEngine() {
      engine.terminate();
      engine = createStockfish();
      engineReady = false;
      engineBusy = false;
      engine.onmessage = (e) => {
        const line = ('' + e.data).trim();
        if (!line) return;
        // console.log('SF:', line);
        if (line === 'uciok') {
          engineReady = true;
          setOptions();
          uci('isready');
        } else if (line === 'readyok') {
          // pronto per giocare
        } else if (line.startsWith('bestmove')) {
          const move = line.split(' ')[1];
          engineBusy = false;
          if (move && move !== '(none)') {
            game.move({ from: move.slice(0,2), to: move.slice(2,4), promotion: 'q' });
            board.position(game.fen());
            pushMoveToList();
            updateStatus();
          } else {
            // nessuna mossa trovata (matto o patta)
            updateStatus();
          }
        }
      };
      uci('uci');
    }

    function setOptions() {
      const skill = clamp(parseInt(skillEl.value || '8', 10), 0, 20);
      uci(`setoption name Skill Level value ${skill}`);
      // Volendo: hash, contempt, threads…
      uci('setoption name Threads value 1');
      uci('setoption name Hash value 16');
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function onDragStart (source, piece, position, orientation) {
      if (game.isGameOver()) return false;
      if ((game.turn() === 'w' && playerSide !== 'white') || (game.turn() === 'b' && playerSide !== 'black')) {
        return false; // non è il tuo turno
      }
      if ((playerSide === 'white' && piece.startsWith('b')) || (playerSide === 'black' && piece.startsWith('w'))) {
        return false; // non trascinare pezzi dell'AI
      }
    }

    function onDrop (source, target) {
      const move = game.move({ from: source, to: target, promotion: 'q' });
      if (move == null) return 'snapback';
      board.position(game.fen());
      pushMoveToList();
      updateStatus();
      // Avvia la risposta dell'AI
      window.setTimeout(aiMove, 50);
    }

    function onSnapEnd () { board.position(game.fen()); }

    function aiMove() {
      if (game.isGameOver()) { updateStatus(); return; }
      if (engineBusy) return;
      engineBusy = true;
      const mt = Math.max(50, parseInt(movetimeEl.value || '500', 10));
      uci('ucinewgame');
      setOptions();
      uci('isready');
      uci(`position fen ${game.fen()}`);
      uci(`go movetime ${mt}`);
    }

    function pushMoveToList() {
      const history = game.history({ verbose: true });
      let out = '';
      for (let i = 0; i < history.length; i+=2) {
        const n = (i/2)+1;
        const w = moveToSan(history[i]);
        const b = history[i+1] ? moveToSan(history[i+1]) : '';
        out += `${n}. ${w} ${b}\n`;
      }
      movesEl.textContent = out.trim();
      movesEl.scrollTop = movesEl.scrollHeight;
    }

    function moveToSan(m){ return m ? (m.san || `${m.from}${m.to}`) : ''; }

    function updateStatus() {
      let text = '';
      if (game.isCheckmate()) {
        text = 'Scacco matto! '; text += (game.turn() === 'w') ? 'Vince il Nero.' : 'Vince il Bianco.';
      } else if (game.isDraw()) {
        text = 'Patta.';
      } else {
        const turn = (game.turn() === 'w') ? 'Bianco' : 'Nero';
        text = `Tocca al ${turn}.`;
        if (game.inCheck()) text += ' (Scacco!)';
      }
      statusEl.textContent = text;
    }

    function newGame() {
      game.reset();
      board.start();
      movesEl.textContent = '';
      updateStatus();
      // Se l'utente ha scelto di giocare Nero, l'AI muove per prima
      if (playerSide === 'black') aiMove();
    }

    function undoLast() {
      if (game.history().length === 0) return;
      if (game.turn() === (playerSide === 'white' ? 'w' : 'b')) {
        // è il tuo turno: significa che l'AI ha appena mosso -> annulla anche la tua precedente per coerenza
        game.undo(); // annulla mossa AI
        game.undo(); // annulla tua mossa
      } else {
        // è il turno dell'AI: annulla solo la tua ultima
        game.undo();
      }
      board.position(game.fen());
      pushMoveToList();
      updateStatus();
    }

    function setSide(side) {
      playerSide = side;
      sideNowEl.textContent = `Lato: ${side === 'white' ? 'Bianco' : 'Nero'}`;
      board.orientation(side === 'white' ? 'white' : 'black');
      newGame();
    }

    function bindUI() {
      document.getElementById('newGameBtn').onclick = newGame;
      document.getElementById('undoBtn').onclick = undoLast;
      document.getElementById('flipBtn').onclick = () => {
        flipped = !flipped;
        board.flip();
      };
      document.querySelectorAll('button[data-side]').forEach(btn => {
        btn.addEventListener('click', () => setSide(btn.dataset.side));
      });
      document.querySelectorAll('button.preset').forEach(btn => {
        btn.addEventListener('click', () => {
          skillEl.value = btn.dataset.skill;
          movetimeEl.value = btn.dataset.mt;
          setOptions();
        });
      });
      skillEl.addEventListener('change', setOptions);
      movetimeEl.addEventListener('change', setOptions);
    }

    function initBoard() {
      board = Chessboard('board', {
        draggable: true,
        position: 'start',
        pieceTheme: 'https://cdn.jsdelivr.net/npm/chessboardjs@1.0.0/www/img/chesspieces/wikipedia/{piece}.png',
        onDragStart,
        onDrop,
        onSnapEnd,
      });
    }

    // Avvio
    bindUI();
    initBoard();
    initEngine();
    updateStatus();
  </script>
</body>
</html>
